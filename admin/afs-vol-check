#!/usr/bin/perl -w
# Copyright (c) 2014, Sine Nomine Associates
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

=pod

=head1 NAME

afs-vol-check

=head1 SYNOPSIS

afs-vol-check [--level=<n>] [--save=<path> | --offline=<path>] [--cell=<cell name>]
             [--verbose] [--version] [--help]

=head1 OPTIONS

=over 8

=item B<--level>=<I<n>>, B<-l> <I<n>>

The B<--level> option specifies the detail level of the checks performed by
B<afs-vol-check> and the amount of data retrieved from the AFS servers. Specify
a number 0, 1, or 2. See DESCRIPTION for the types of checks performed for each
level. The default level is 0 (zero).

=item B<--cell>=<I<cell name>>, B<-c> <I<cell name>>

Name of the cell in which to run the AFS commands when gathering data
from the AFS servers.

=item B<--save>=<I<path>>

Save the output of the C<vos> commands into a set of files. The files are
created in the directory I<path>, which must already exist and must be emtpy.
The created files can be processed later using the B<--offline> option.

=item B<--offline>=<I<path>>

Instead of running C<vos>, read the set of files in I<path> containing the
output from a previous C<afs-vol-check> invoked with the B<--save> option.

=item B<--verbose>, B<-v>

Print informational messages.

=item B<--help>, B<-h>

Print this help then exit.

=item B<--version>

Print the version number and exit.

=back

=head1 DESCRIPTION

B<afs-vol-check> retrieves AFS volume information from the AFS volume location
database and, depending on the B<--level> option, retrieves information from
each file server.  B<afs-vol-check> then performs a series of contistency and
status checks based on the retrieved data.

The AFS B<vos> command is used to gather information. The B<vos> command must
be in the current C<PATH>.  An AFS token is not required to run
B<afs-vol-check>.

=head2 Level 0 Checks

The following checks are performed when B<--level> is 0 (the default
value).

=over 8

=item missing ro clone sites

Search for replicated volumes which do not have a read-only defined
on the same partition as the read-write volume.

=item stale locks

Search for locked volumes which do not have active transactions.

=item failed releases

Search for failed releases based on the vldb release flags and
stale locks check.

=back

=head2 Level 1 Checks

In addition to the level 0 checks, the following checks are performed when
B<--level> is set to 1. B<afs-vol-check> will run B<vos listvol -fast> for each
file server when B<--level> is set to 1.

=over

=item missing volumes

Search for volumes which have an entry in the vldb but are not
found on the fileserver.

=item orphan volumes

Search for volumes which were found on the fileserver but do not
have an entry in the vldb.

=item stray volumes

Search for volumes which have vldb entry, but are not located
at the site indicated by the vldb entry (and the site indicated by
the vldb entry does not contain the same volume id).

=item rogue volumes

Search for volumes which have a duplicate volume id with a
volume that has a vldb entry.

=back

=head2 Level 2 Checks

In addition to the level 1 checks, the following checks are performed when
B<--level> is set to 2. B<afs-vol-check> will run B<vos listvol> for each file
server when B<--level> is set to 1.

=over

=item names and types

Verify the volume name and type in the volume header matches
the name and type in the vldb entry for each volume.

=item offline volumes

Search for volumes marked as offline.

=back

=head1 COPYRIGHT

Copyright (c) 2014, Sine Nomine Associates
All rights reserved.

=cut

use strict;
use Getopt::Long;
use Pod::Usage;
use Time::Local;

our $VERSION = "1.10";
our $VOS; # /<path>/vos
our $U2A; # uuid to address table

# vldb release flags
use constant REL_NOT => 1;
use constant REL_NEW => 2;
use constant REL_OLD => 4;

# command line options
my $opt_help = 0;
my $opt_level = 0;   # fastest, but least checks
my $opt_verbose = 0;
my $opt_cell = "";   # use local cell
my $opt_version = 0;
my $opt_save = "";
my $opt_offline = "";

GetOptions(
    "cell|c=s" => \$opt_cell,
    "level=i" => \$opt_level,
    "verbose|v" => \$opt_verbose,
    "help|h|?" => \$opt_help,
    "version" => \$opt_version,
    "save=s" => \$opt_save,
    "offline=s" => \$opt_offline,
) or pod2usage(2);
if ($opt_help) {
    pod2usage(1);
}
if ($opt_version) {
    print $VERSION, "\n";
    exit(0);
}
if ($opt_save and $opt_offline) {
    fatal("Cannot run with --save and --offline.");
}
if ($opt_save) {
    unless (-d $opt_save) {
        fatal("--save: directory does not exist: $opt_save");
    }
    unless (is_dir_empty($opt_save)) {
        fatal("--save: directory is not empty: $opt_save");
    }
}
unless ($opt_offline) {
    # Search for the vos command, first in the PATH, then in some
    # common hiding places. Use the first one found.
    ($VOS) = grep { -x $_ } map { $_ ."/vos" } (
        split(/:/, $ENV{PATH}),
        qw(/usr/afs/bin /usr/afsws/bin /usr/afsws/etc),
        qw(/usr/bin /usr/sbin /usr/local/bin /usr/local/sbin),
    );
    unless ($VOS) {
        fatal("Failed to find the vos command.");
    }
}

exit main();

#------------------------------------------------------------------
# Main routine.
#
sub main
{
    my $fs = vos_listaddrs();
    my $vldb = vos_listvldb($fs);
    my $tx = cell_vos_status($vldb->{servers});
    my $vols = cell_vos_listvol($vldb->{servers});

    $U2A = $vldb->{servers}->{u2a}; # for printing addresses instead of uuids
    check_for_old_servers($vldb->{servers});
    check_for_missing_volumes($vldb, $vols);
    check_for_stray_volumes($vldb, $vols);
    check_for_broken_volume_names($vldb, $vols);
    check_for_missing_ro_clone_site($vldb);
    check_for_offline_volumes($vldb, $vols);
    check_for_stale_locks_and_failed_releases($vldb, $tx);

    return 0; # all checks ran
}

#------------------------------------------------------------------
# Returns true if directory is empty.
sub is_dir_empty
{
    my $path = shift;

    opendir(my $dir, $path) or die "FATAL: Failed to open $path: $!";
    while (my $dent = readdir($dir)) {  # older versions of perl dont set $_
        next if $dent =~ /^[.]\z/;
        next if $dent =~ /^[.][.]\z/;
        closedir($dir);
        return 0;
    }
    closedir($dir);
    return 1;
}

#------------------------------------------------------------------
sub check_for_old_servers
{
    my $servers = shift;
    my %active = map { $_ => 1 } @{ $servers->{active} };

    foreach my $uuid (keys(%{ $servers->{u2a} })) {
        unless ($active{$uuid}) {
            check_failed("old file server in vldb: $uuid (".
                join(", ", @{ $servers->{u2a}->{$uuid} }) .")");
        }
    }
}

#------------------------------------------------------------------
sub check_for_missing_volumes
{
    unless ($opt_level >= 1) {
        info("skipping missing volumes checks.");
        return;
    }
    info("checking for missing volumes ...");
    my $vldb = shift;
    my $vols = shift;
    my $sv = sites_hash($vols->{list},  "server");
    foreach my $site (@{ $vldb->{sites} }) {
        my $key = site_key($site);
        unless ($key && exists($sv->{$key})) {
            # Do not report sites which have not been released yet as missing.
            unless ($site->{type} eq "RO" && $site->{flag}) {
                check_failed("missing volume: $site->{name} ($site->{id}) at ". location($site));
                $site->{missing} = 1;
            }
        }
    }
}

#------------------------------------------------------------------
#
# Walk the list of volumes found on the file servers. Check for a matching
# vldb site entry for each volume.
#
# If no vldb entries exist for a volume id, the volume is called "orphaned".
# A vldb site entry can be made to refer to the orphaned volume. (The method
# depends on the volume type.)
#
# If all the vldb site entries for the volume (id, type) are "broken links"
# (that is there are no volumes located at the sites pointed to by the
# vldb entries) the volume is called "stray".  The vldb site entry can be
# updated to point to the stray volume.
#
# If at least one unbroken vldb site entry exists for the volume (id, type),
# this volume is called "rogue".  It could be an old version of the volume
# which is currently in use.
#
sub check_for_stray_volumes
{
    unless ($opt_level >= 1) {
        info("skipping stray volumes checks.");
        return;
    }
    info("checking for stray volumes ...");
    my $vldb = shift;
    my $vols = shift;
    my $db = sites_hash($vldb->{sites}, "vldb");

    # first pass: find unbroken vldb entries for stray vs rogue warnings.
    foreach my $site (@{ $vols->{list} }) {
        my $key = site_key($site);
        if ($key && $db->{$key}) {
            my $vs = $db->{$key};
            $vs->{child} = $site;
            $site->{parent} = $vs;
        }
    }

    # second pass: find orphaned/stray/rogue volumes
    foreach my $site (@{ $vols->{list} }) {
        unless ($site->{parent}) {
            my $vol = site_string($site);
            my $inuse = "";
            my $warn = "";
            my $id = $site->{id};
            if ($vldb->{numbers}->{$id}) {
                # Get the list of vldb sites for this volume id. If at least
                # one of them is not broken, then this is called a "rogue".
                my @vs = grep {$_->{id} eq $id} @{ $vldb->{numbers}->{$id}->{sites} };
                my @c = grep { $_->{child} } @vs;
                my @a = map { location($_) } @vs;

                $warn = scalar(@c) ? "rogue" : "stray";
                $inuse = scalar(@a) ? "; in use at ". join(", ", @a) : "";
            }
            else {
                $warn = "orphan";
            }
            check_failed("$warn volume: $vol at ". location($site) . $inuse);
        }
    }
}


#------------------------------------------------------------------
sub check_for_broken_volume_names
{
    unless ($opt_level >= 2) {
        info("skipping volume names and types checks.");
        return;
    }
    info("checking volume names and types ...");
    my $vldb = shift;
    my $vols = shift;
    my $db = sites_hash($vldb->{sites}, "vldb");
    foreach my $site (@{ $vols->{list} }) {
        my $key = site_key($site);
        if ($key && exists($db->{$key})) {
            my $v = $db->{$key};

            if ($site->{name} && ($v->{name} ne $site->{name})) {
                check_failed("name mismatch: $site->{name} ($site->{id}) ".
                     "should be $v->{name} ".
                     "at ". location($site));
            }
            if ($site->{type} && ($v->{type} ne $site->{type})) {
                my $vol = site_string($site);
                check_failed("type mismatch: $vol ".
                     "$site->{type} should be $v->{type} ".
                     "at ". location($site));
            }
        }
    }
}

#------------------------------------------------------------------
sub check_for_stale_locks_and_failed_releases
{
    my $vldb = shift;
    my $tx = shift;
    my %messages = ();

    info("checking for stale locks ...");
    VOL: while (my ($id, $v)=each(%{ $vldb->{numbers} })) {
        next VOL unless $v->{locked};
        info("checking volume lock: $v->{name} $id");
        foreach my $type (qw(rw ro bk)) {
            if ($v->{$type} && tx_lookup($tx, $v->{$type})) {
                next VOL;
            }
        }
        $v->{stalelock} = 1;
        if ($v->{op}) {
            $messages{$id} = "possible stale lock: op $v->{op} $v->{name} ($v->{rw})";
        }
        else {
            $messages{$id} = "possible stale lock: $v->{name} ($v->{rw})";
        }
    }

    info("checking for failed releases ...");
    while (my ($id, $v)=each(%{ $vldb->{numbers} })) {
        if ($v->{rflags}) {  # one or more vldb release flags were seen
            info("release flags detected: $v->{name} $v->{rw}");
            if ($v->{locked} && $v->{op} && $v->{op} eq 'release' && !$v->{stalelock}) {
                info("release in progress: $v->{name} $v->{rw}");
            }
            elsif ($v->{rflags} == REL_NOT) {
                $messages{$id} = "not released: $v->{name} ($v->{rw})";
            }
            else {
                $messages{$id} = "failed release: $v->{name} ($v->{rw})";
            }
        }
    }

    while (my ($k, $v) = each %messages) {
        check_failed($v);
    }
}

#------------------------------------------------------------------
sub check_for_missing_ro_clone_site
{
    my $vldb = shift;

    info("checking for missing ro clone sites ...");
    while (my ($id, $v)=each(%{ $vldb->{numbers} })) {
        my @ro = grep { $_->{type} eq "RO" } @{ $v->{sites} };
        if (@ro) { # if there is at least one ro site
            # get the rw site. (The presence of one rw site was
            # checked when $vldb was created, so assert if missing.)
            my ($rw) = grep { $_->{type} eq "RW" } @{ $v->{sites} };
            die "FATAL: vldb: missing read/write site: $v->{name} ($v->{rw})" unless $rw;

            # Complain if the read-only clone entry is missing.
            # Cross-device link errors are checked before this routine.
            my $rc = grep {
                $_->{serv} eq $rw->{serv} &&
                $_->{part} eq $rw->{part}
            } @ro;
            unless ($rc) {
                check_failed("addsite needed: $v->{name} ($v->{rw}) at ".
                    location($rw));
            }
        }
    }
}

#------------------------------------------------------------------
sub check_for_offline_volumes
{
    my $vldb = shift;
    my $vols = shift;

    unless ($opt_level >= 2) {
        info("skipping offline volume checks.");
        return;
    }

    info("checking for offline volumes ...");
    foreach my $site (@{ $vols->{list} }) {
        if ($site->{status} ne "OK") {
            my $vol = site_string($site);
            check_failed("volume offline: $vol at ". location($site));
        }
    }
    foreach my $id (@{ $vols->{busy} }) {
        my $v = vldb_lookup_entry($vldb, $id);
        if ($v && $v->{locked} && !$v->{stalelock}) {
            next;  # skip warning if a transaction is in progress
        }
        check_failed("volume busy: $id");
    }
    foreach my $id (@{ $vols->{unattached} }) {
        check_failed("volume attach error: $id");
    }
}

#------------------------------------------------------------------
# Print an informational message when in verbose mode.
#
sub info
{
    if ($opt_verbose) {
        my $msg = shift;
        chomp($msg);
        print "INFO: $msg\n";
    }
}

#------------------------------------------------------------------
# Print a warning message to stdout.
#
sub warning
{
    my $msg = shift;
    chomp($msg);
    print "WARNING: $msg\n";
}

#------------------------------------------------------------------
# Print a error message to stderr.
#
sub error
{
    my $msg = shift;
    chomp($msg);
    print STDERR "ERROR: $msg\n";
}

#------------------------------------------------------------------
# Print a fatal error message to stderr and exit.
#
# Use this sub if the line number of the caller is not needed.
#
sub fatal
{
    my $msg = shift;
    chomp($msg);
    die "FATAL: $msg\n";
}

#------------------------------------------------------------------
# A check failed, print a warning.
#
sub check_failed
{
    my $msg = shift;
    warning($msg);
}

#------------------------------------------------------------------
# Validate an expression or exit with an error.
#
sub assert
{
    my $expr = shift;
    my $msg = shift;
    $expr or die "ASSERT: $msg\n";
}

#------------------------------------------------------------------
# Parse a date string formatted by ctime().
#
sub parse_date
{
    my $string = shift;
    my $months = {"Jan"=>0, "Feb"=>1, "Mar"=>2, "Apr"=>3, "May"=>4, "Jun"=>5,
                  "Jul"=>6, "Aug"=>7, "Sep"=>8, "Oct"=>9, "Nov"=>10, "Dec"=>11};

    if ($string =~ /^(\d+)/) {
        return $1; # assume all digits is a timestamp
    }
    if (my ($m, $day, $hour, $min, $sec, $year)=($string=~
        /^\w{3}\s+(\w{3})\s+(\d{1,2})\s+(\d{2}):(\d{2}):(\d{2})\s+(\d{4})$/)) {
        if (!exists($months->{$m})) {
            die "FATAL: parse_date: invalid month: $m";
        }
        my $time = timelocal($sec, $min, $hour, $day, $months->{$m}, $year);
        return $time;
    }
    die "FATAL: parse_date: invalid date string: $string";
}

#------------------------------------------------------------------
# Create the volume name from the rw base name and volume type.
#
sub volname
{
    my ($name, $type) = @_;
    if ($type =~ /^RO$/i) {
        $name .= ".readonly";
    }
    elsif ($type =~ /^BK$/i) {
        $name .= ".backup";
    }
    return $name;
}

#------------------------------------------------------------------
# Add parent volume id hash entry.
#
sub vldb_add_parent_id
{
    my ($vldb, $parent, $id) = @_;

    if ($id != 0) {
        if (exists($vldb->{parents}->{$id})) {
            unless ($vldb->{parents}->{$id} == $parent) {
               error("vldb: conflicting parent id numbers for volume $id");
            }
        }
        else {
            $vldb->{parents}->{$id} = $parent;
        }
    }
}

#------------------------------------------------------------------
# Add a volume entry from the vos listvldb output.
#
sub vldb_add_entry
{
    my $vldb = shift;
    my $v = shift;

    # sanity checks
    assert(exists($v->{name}),   "vldb: volume name missing");

    my $name = $v->{name};
    assert(exists($v->{rw}),     "vldb: read/write volume id missing: $name");
    assert($v->{rw} != 0,        "vldb: read/write volume id is zero: $name");

    assert(exists($v->{sites}),  "vldb: sites missing: $name");
    assert(exists($v->{nsites}), "vldb: number of sites missing: $name");

    my $n = scalar(@{$v->{sites}});
    assert($n > 0,               "vldb: no sites found: $name");
    assert($n == $v->{nsites},   "vldb: not all sites found: $name");

    my @rw = grep {$_->{type} eq "RW"} @{$v->{sites}};
    assert(scalar(@rw) != 0, "vldb: no read/write site found: $name");
    assert(scalar(@rw) == 1, "vldb: multiple read/write sites found: $name");

    # Save the sites to the sites list.
    foreach my $s (@{ $v->{sites} }) {
        push(@{ $vldb->{sites} }, $s);
    }
    # Add the implied backup clone entry, if one.
    if (exists($v->{bk}) && $v->{bk} != 0) {
        my $r = $rw[0];  # the rw site, from the grep above
        my $b = {serv=>$r->{serv}, part=>$r->{part}, parent=>$r->{parent},
                 id=>$v->{bk}, type=>"BK", name=>volname($r->{name}, "BK") };
        push(@{ $vldb->{sites} }, $b);
    }

    # Save the volume info by name and number.
    my $id = $v->{rw};
    if (exists($vldb->{names}->{$name})) {
        error("vldb: duplicate volume name: $name");
    }
    else {
        $vldb->{names}->{$name} = $v;
    }
    if (exists($vldb->{numbers}->{$id})) {
        error("vldb: duplicate volume number: $id");
    }
    else {
        $vldb->{numbers}->{$id} = $v;
    }

    # Save the parent id for each id in the volume group (including the rw)
    foreach my $type (qw(rw ro bk rc)) {
        if (exists($v->{$type})) {
            vldb_add_parent_id($vldb, $id, $v->{$type});
        }
    }
}

#------------------------------------------------------------------
# Lookup an entry by volume id.
#
sub vldb_lookup_entry
{
    my $vldb = shift;
    my $id = shift;
    my $v;

    my $parent = $vldb->{parents}->{$id};
    if ($parent) {
        $v = $vldb->{numbers}->{$parent};
    }
    return $v;
}

#------------------------------------------------------------------
sub vos_listaddrs
{
    my $errors = 0;
    my $vos;
    my $save;
    my $errormsg = "";
    my $state = 0;
    my $uuid;
    my $u2a = {}; # uuid to list of addresses
    my $a2u = {}; # address to uuid

    my $options = "-noauth -noresolve -printuuid";
    if ($opt_cell) {
        $options .= " -cell $opt_cell";
    }
    if ($opt_offline) {
        my $file = "$opt_offline/listaddrs";
        info("reading: $file");
        open($vos, "<", $file) or die "FATAL: Failed to open $file: $!";
        $errormsg = "failed closing $file";
    } else {
        my $cmd = "$VOS listaddrs $options";
        info("running: ". $cmd);
        open($vos, "$cmd |") or die "FATAL: Failed to run $cmd: $!";
        $errormsg = "failed running: $cmd";
        if ($opt_save) {
            my $file = "$opt_save/listaddrs";
            info("saving to file $file");
            open($save, ">", $file) or die "FATAL: Failed to open $file: $!";
        }
    }
    while (<$vos>) {
        print $save $_ if $save;
        chomp;
        if ($state == 0) {
            if (/^UUID: (.*)/) {
                $uuid = $1;
                if ($u2a->{$uuid}) {
                    die "FATAL: duplicate fileserver uuid: $_";
                }
                $u2a->{$uuid} = [];
                $state = 1;
                next;
            }
        }
        if ($state == 1) {
            if (/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/) {
                my $addr = $1;
                if ($a2u->{$addr}) {
                    die "FATAL: duplicate fileserver address: $_";
                }
                push(@{ $u2a->{$uuid} }, $addr);
                $a2u->{$addr} = $uuid;
                next;
            }
            if (/^$/) {
                $state = 0;
                next;
            }
        }
        die "FATAL: error reading listaddr: state=$state, line=$_";
    }
    if ($state != 0) {
        die "FATAL: trailing data while reading listaddr: line=$_";
    }
    close($vos);
    close $save if $save;

    return {u2a=>$u2a, a2u=>$a2u};
}

#------------------------------------------------------------------
# Run vos listvldb and read the output.
#
sub vos_listvldb
{
    my $fs = shift; # file servers; address to uuid, and uuid to address
    my $errors = 0;
    my $vos;
    my $save;
    my $errormsg = "";
    my $vldb = {
        names => {},     # hash of info by rw volume names
        numbers => {},   # hash of info by rw volume numbers
        parents => {},   # hash of parent id by volume id
        sites => [],     # list of rw/ro/bk volume sites
        servers => {
          active=>[],    # uuids of the servers which have volumes
          u2a=>$fs->{u2a},  # map of uuids to list of ip addresses
          a2u=>$fs->{a2u},  # map of ip address to uuid
        },
    };

    my $options = "-quiet -noauth -noresolve -nosort";
    if ($opt_cell) {
        $options .= " -cell $opt_cell";
    }
    if ($opt_offline) {
        my $file = "$opt_offline/listvldb";
        info("reading: $file");
        open($vos, "<", $file) or die "FATAL: Failed to open $file: $!";
        $errormsg = "failed closing $file";
    } else {
        my $cmd = "$VOS listvldb $options";
        info("running: ". $cmd);
        open($vos, "$cmd |") or die "FATAL: Failed to run $cmd: $!";
        $errormsg = "failed running: $cmd";
        if ($opt_save) {
            my $file = "$opt_save/listvldb";
            info("saving to file $file");
            open($save, ">", $file) or die "FATAL: Failed to open $file: $!";
        }
    }

    my $v;  # volume group
    while (<$vos>) {
        print $save $_ if $save;
        chomp;
        next if /^\s*$/; # skip blank lines
        if (/^(\S+)\s*$/) {
            if (!defined($v)) { # first entry
                $v = {};
            }
            if (exists($v->{name})) {
                eval {
                    vldb_add_entry($vldb, $v);
                };
                if ($@) {
                    $errors++;
                    error($@);
                }
            }
            $v = {name=>$1, sites=>[], locked=>0};
            next;
        }
        unless (defined($v) && exists($v->{name})) {
            die "FATAL: vldb: error reading listvldb";
        }
        if (/^\s+(RWrite|ROnly|Backup|RClone):/) {
            if (/RWrite:\s+(\d+)/) {
                $v->{rw} = $1;
            }
            if (/ROnly:\s+(\d+)/) {
                $v->{ro} = $1;
            }
            if (/Backup:\s+(\d+)/) {
                $v->{bk} = $1;
            }
            if (/RClone:\s+(\d+)/) {
                $v->{rc} = $1;
            }
            next;
        }
        if (/^\s+number of sites -> (\d+)/) {
            $v->{nsites} = $1;
            next;
        }
        if (m{^\s+server (\S+) partition /vicep(\w+) (\w+) Site}) {
            my ($addr, $part, $type) = ($1, $2, $3);
            my $parent = $v->{rw};
            my $id;
            my $flag;

            if (/-- Not released/) {
                $flag = REL_NOT;
            }
            elsif (/-- New release/) {
                $flag = REL_NEW;
            }
            elsif (/-- Old release/) {
                $flag = REL_OLD;
            }

            if ($type eq "RW") {
                $id = $v->{rw};
            }
            elsif ($type eq "RO") {
                if ($v->{ro}) {
                    $id = $v->{ro};
                }
                else {
                    unless ($flag eq REL_NOT) { # ro volume not created yet
                        $errors++;
                        error("vldb: error reading listvldb: ro id not found: $v->{name}");
                    }
                }
            }
            else {
                $errors++;
                error("vldb: error reading listvldb: unexpected volume type: $v->{name}");
            }
            my $uuid = $fs->{a2u}->{$addr};  # lookup server uuid from ip4v address
            unless ($uuid) {
                fatal("vldb: failed to find uuid for server address $addr while reading listvldb");
            }
            my $vs = {serv=>$uuid, part=>$part, parent=>$parent,
                      type=>$type, name=>volname($v->{name}, $type)};
            if ($id) {
                $vs->{id} = $id; # id is not available for ro sites before the first release.
            }
            if ($flag) {
                $v->{rflags} |= $flag;
                $vs->{flag} = $flag;
            }
            push(@{$v->{sites}}, $vs);
            next;
        }
        if (/^\s+Volume is currently LOCKED/) {
            $v->{locked} = 1;
            next;
        }
        if (/^\s+Volume is locked for a (\S+) operation/) {
            $v->{op} = $1;
            next;
        }
    }
    if (exists($v->{name})) {
        eval {
            vldb_add_entry($vldb, $v);
        };
        if ($@) {
            $errors++;
            error($@);
        }
    }

    # Get a unique list of active servers.
    my %shash = map { $_->{serv} => 1 } @{ $vldb->{sites} };
    $vldb->{servers}->{active} = [keys(%shash)];

    close($vos);
    unless ($? == 0) {
        $errors++;
        error("vos listvldb failed: code=$?");
    }
    if ($errors) {
        die "FATAL: Errors while reading vldb.";
    }
    close $save if $save;
    return $vldb;
}

#------------------------------------------------------------------
# Run vos listvol for a server and read the output.
#
# Use the -fast option to get just the volume id list. This is a
# much lighter weight operation on the fileserver.
#
sub vos_listvol
{
    my $vol = shift;
    my $uuid = shift;
    my $addr = shift;
    my $vos;
    my $save;
    my $errormsg = "";

    my $options = "-server $addr -noauth -noresolve";
    if ($opt_level >= 2) {
        $options .= " -format";  # slowest, all volume headers
    }
    else {
        $options .= " -fast";    # faster, just the volume ids
    }
    if ($opt_cell) {
        $options .= " -cell $opt_cell";
    }
    if ($opt_offline) {
        my $file = "$opt_offline/$addr.listvol";
        if ($options =~ /\-fast/) {
            $file .= ".fast";
        }
        info("reading: $file");
        open($vos, "<", $file) or die "FATAL: Failed to read offline file $file: $!";
        $errormsg = "failed closing $file";
    }
    else {
        my $cmd = "$VOS listvol $options";
        info("running: ". $cmd);
        open($vos, "$cmd |") or die "FATAL: Failed to run $cmd: $!";
        $errormsg = "failed running: $cmd";
        if ($opt_save) {
            my $file = "$opt_save/$addr.listvol";
            if ($options =~ /\-fast/) {
                $file .= ".fast";
            }
            info("saving to file $file");
            open($save, ">", $file) or die "FATAL: Failed to open $file: $!";
        }
    }

    my $state = 0;
    my $v;
    my $part;  # current partition
    while(<$vos>) {
        print $save $_ if $save;
        chomp;
        next if /^\s*$/;                  # skip blank lines
        next if /^Total volumes/;         # skip summary lines
        if (m{Total number of volumes on server (\S+) partition /vicep(\w+)}) {
            $part = $2;
            next;
        }
        if (/\*\*\*\* Volume (\d+) is busy \*\*\*\*/) {
            push(@{ $vol->{busy} }, $1);
            next;
        }
        if (/\*\*\*\* Could not attach volume (\d+) \*\*\*\*/) {
            push(@{ $vol->{unattached} }, $1);
            next;
        }
        if ($options =~ /\-fast/) {
            if (/^(\d+)\s*$/) {
                if ($1 == 0) {
                    error("vol: volume id is zero: $addr:$part");
                } else {
                    my $v = {serv=>$uuid, part=>$part, id=>$1};
                    push(@{ $vol->{list} }, $v);
                }
            }
            next;
        }

        if ($state == 0) {
            if (/^BEGIN_OF_ENTRY/) {
                $state = 1;
                $v = {serv=>$uuid};
                next;
            }
        }
        if ($state == 1) {
            if (/^END_OF_ENTRY/) {
                my $ok = 1;
                # the following should always be provided
                foreach my $k (qw(id serv status)) {
                    unless (exists $v->{$k}) {
                        $ok = 0;
                        error("vol: missing $k field in listvol");
                    }
                }
                if (exists $v->{status}) {
                    if ($v->{status} eq "OK") {
                        foreach my $k (qw(name type)) {
                            unless (exists $v->{$k}) {
                                error("vol: missing $k field in listvol");
                            }
                        }
                    }
                    # Old versions of vos put garbage in "name" when
                    # status was not ok.
                    if ($v->{status} ne "OK" and exists $v->{name}) {
                        delete $v->{name};
                    }
                }
                if ($ok) {
                    push(@{ $vol->{list} }, $v);
                }
                $state = 0;
                next;
            }
            if (/^(name|id|type|status)\s+(\S+)/) {
                if ($1 eq "id" && $2 == 0) {
                    error("vol: volume id is zero on server $addr");
                    next;
                }
                $v->{$1} = $2;
                next;
            }
            if (m{^part\s+/vicep(\w+)}) {
                $v->{part} = $1;
            }
            next;
        }
        die "FATAL: vol: error reading listvol for server $addr: $_";
    }
    close($vos);
    unless ($? == 0) {
        die "FATAL: $errormsg: code=$?";
    }
    close $save if $save;
}

#------------------------------------------------------------------
# Run vos listvol for each file server.
#
sub cell_vos_listvol
{
    my $servers = shift;
    my $vol = {
        list => [],
        busy => [],
        unattached => [],
    };
    unless ($opt_level >= 1) {
        return undef;
    }
    foreach my $uuid (@{ $servers->{active} }) {
        my $addr = $servers->{u2a}->{$uuid}->[0];
        vos_listvol($vol, $uuid, $addr);
    }
    return $vol;
}

#------------------------------------------------------------------
# Lookup volume transactions by id and proc.
#
sub tx_lookup
{
    my ($tx, $id, $proc) = @_;  # proc is optional
    my @t;
    if ($proc) {
        @t = grep {$_->{id} eq $id && $_->{proc} eq $proc} @{ $tx->{list} };
    }
    else {
        @t = grep {$_->{id} eq $id} @{ $tx->{list} };
    }
    return @t; # return the matching list
}

#------------------------------------------------------------------
# Run vos status and read the output.
#
sub vos_status
{
    my $tx = shift;
    my $uuid = shift;
    my $addr = shift;
    my $vos;
    my $save;
    my $errormsg = "";

    my $options = "-server $addr -noauth -noresolve";
    if ($opt_cell) {
        $options .= " -cell $opt_cell";
    }
    if ($opt_offline) {
        my $file = "$opt_offline/$addr.status";
        info("reading: $file");
        open($vos, "<", $file) or die "FATAL: Failed to open offline file $file: $!";
        $errormsg = "failed closing $file";
    }
    else {
        my $cmd = "$VOS status $options";
        info("running: ". $cmd);
        open($vos, "$cmd |") or die "FATAL: Failed to run $cmd: $!";
        $errormsg = "failed running: $cmd";
        if ($opt_save) {
            my $file = "$opt_save/$addr.status";
            info("saving to file $file");
            open($save, ">", $file) or die "FATAL: Failed to open $file: $!";
        }
    }

    my ($state, $total, $count, $t) = (0, 0, 0, undef);
    while(<$vos>) {
        print $save $_ if $save;
        chomp;
        next if /^\s*$/;  # skip blank lines
        if ($state == 0) {
            last if /^No active transactions on/;
            if (/^Total transactions: (\d+)/) {
                $total = $1;
            }
            if (/^------/) {
                $t = {addr=>$addr, uuid=>$uuid};
                $state = 1;
            }
            next;
        }
        if ($state == 1) {
            if (/transaction: (\d+)/) {
                $t->{tid} = $1;
            }
            if (/created: (.+)$/) {
                $t->{created} = parse_date($1);
            }
            if (/lastActiveTime: (.+)$/) {
                $t->{last} = parse_date($1);
            }
            if (/volume: (\d+)/) {
                $t->{id} = $1;
            }
            if (m{partition: /vicep(\S+)}) {
                $t->{part} = $1;
            }
            if (/procedure: (\S+)/) {
                $t->{proc} = $1;
            }
            if (/packetRead: (\d+)/) {
                $t->{read} = $1;
            }
            if (/packetSend: (\d+)/) {
                $t->{send} = $1;
            }
            if (/lastReceiveTime: (.+)$/) {
                $t->{recvtime} = parse_date($1);
            }
            if (/lastSendTime: (.+)$/) {
                $t->{sendtime} = parse_date($1);
            }
            if (/^------/) {
                push(@{ $tx->{list} }, $t);
                $count++;
                $state = 0;
            }
            next;
        }
    }
    close($vos);
    unless ($? == 0) {
        die "FATAL: $errormsg: code=$?";
    }
    if ($total != $count) {
        die "FATAL: failed to read all of the transactions from vos status.";
    }
    close $save if $save;
}

#------------------------------------------------------------------
# Run vos status for each file server.
#
sub cell_vos_status
{
    my $servers = shift;
    my $tx = {list => []};
    foreach my $uuid (@{ $servers->{active} }) {
        my $addr = $servers->{u2a}->{$uuid}->[0];
        vos_status($tx, $uuid, $addr);
    }
    return $tx;
}

#------------------------------------------------------------------
# Format a human readable string for the volume site.
#
sub site_string
{
    my $site = shift;
    # name and type is not available when vos listvol was
    # run with the -fast option.
    return sprintf("%s (%s) [%s]",
        $site->{name} ? $site->{name} : "<unknown>",
        $site->{id} ? $site->{id} : "<unknown>",
        $site->{type} ? lc($site->{type}) : "??");
}

#------------------------------------------------------------------
# Format the server/partition string.
#
sub location
{
    my $site = shift;
    my $addr = site_get_addr($site);
    return sprintf("%s:%s",
        $addr ? $addr : "<unknown>",
        $site->{part} ? $site->{part} : "?");
}

#------------------------------------------------------------------
# Lookup the volume site address from the uuid. Return the first
# address given by listaddrs for the uuid.
#
# Note: The U2A table is created from the output of vos listaddrs
#       and put into a global table for lookups.
#
sub site_get_addr
{
    my $site = shift;
    my $addr;
    if ($site->{serv} && $U2A->{$site->{serv}}) {
        $addr = $U2A->{$site->{serv}}->[0];
    }
    return $addr;
}

#------------------------------------------------------------------
# Create a tuple of the volume id and location.
#
sub site_key
{
    my $site = shift;
    if ($site->{flag} && $site->{flag} == REL_NOT) {
       info("skipping unreleased site: ". site_string($site) ." at ". location($site));
       return undef;
    }
    assert(exists($site->{serv}), "site is missing 'serv': ". site_string($site));
    assert(exists($site->{part}), "site is missing 'part': ". site_string($site));
    assert(exists($site->{id}), "site is missing 'id': ". site_string($site));
    assert($site->{id} != 0, "site id is zero: ". site_string($site));
    return sprintf("%s:%s:%d", $site->{serv}, $site->{part}, $site->{id});
}

#------------------------------------------------------------------
# Create a hash table of volume sites.
#
sub sites_hash
{
    my $sites = shift;
    my $source = shift;
    my $hash = {};

    foreach my $site (@{ $sites }) {
        my $key = site_key($site);
        next unless $key;
        if (exists($hash->{$key})) {
            unless ($hash->{$key}->{dupwarn}) {
                check_failed("$source: duplicate volume detected: $key");
                $hash->{$key}->{dupwarn} = 1;
            }
        }
        else {
            $hash->{$key} = $site;
        }
    }
    return $hash;
}


